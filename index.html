<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OBR Vox - Red Edition</title>
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="./manifest.json">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body { 
            background-color: #000;
            color: #ef4444; /* Rojo base */
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            filter: grayscale(100%) contrast(1.2) brightness(0.6);
            transform: scaleX(1);
        }

        .night-vision-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 0, 0, 0.4);
            pointer-events: none;
            z-index: 1;
            box-shadow: inset 0 0 150px rgba(0,0,0,1);
        }

        .ui-layer {
            position: relative;
            z-index: 10;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .tactical-grid {
            background-image: 
                linear-gradient(rgba(239, 68, 68, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(239, 68, 68, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 2;
        }

        /* --- EFECTO TERROR PARA EL TEXTO --- */
        .terror-text {
            color: #ffffff;
            text-shadow: 4px 4px 0px #8b0000;
            animation: terror-shake 0.3s infinite;
            transform-origin: center;
        }

        @keyframes terror-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); text-shadow: 4px 4px 0px #8b0000; }
            20% { transform: translate(-3px, 0px) rotate(-1deg); text-shadow: -4px 4px 0px #ff0000; opacity: 0.9;}
            40% { transform: translate(1px, -1px) rotate(1deg); text-shadow: 4px -4px 0px #8b0000; }
            60% { transform: translate(-3px, 1px) rotate(0deg); text-shadow: -4px -4px 0px #ff0000; opacity: 1;}
            80% { transform: translate(-1px, -1px) rotate(1deg); text-shadow: 2px 2px 0px #8b0000; }
            100% { transform: translate(1px, -2px) rotate(-1deg); text-shadow: 4px 4px 0px #ff0000; }
        }

        .slam-in {
            animation: slam 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes slam {
            0% { transform: scale(3); opacity: 0; }
            50% { transform: scale(0.9); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* --- EFECTO LATIDO PARA EL LOGO --- */
        .logo-spectral {
            animation: spectral-pulse 3s infinite ease-in-out;
        }
        @keyframes spectral-pulse {
            0% { filter: drop-shadow(0 0 5px rgba(220, 38, 38, 0.2)) grayscale(100%); opacity: 0.7; transform: scale(1); }
            50% { filter: drop-shadow(0 0 25px rgba(255, 0, 0, 0.8)) grayscale(0%); opacity: 1; transform: scale(1.05); }
            100% { filter: drop-shadow(0 0 5px rgba(220, 38, 38, 0.2)) grayscale(100%); opacity: 0.7; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- CONFIGURACIÓN ---
        const AUDIO_BASE_PATH = './audio/';
        const BACKGROUND_AUDIO = './FONDO_1.mp3';
        const LOGO_PATH = './obr-logo.png';

        // --- ICONOS ---
        const IconGhost = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M9 10h.01"/><path d="M15 10h.01"/><path d="M12 2a8 8 0 0 0-8 8v12l3-3 2.5 2.5L12 19l2.5 2.5L17 19l3 3V10a8 8 0 0 0-8-8z"/></svg>;
        const IconActivity = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>;
        const IconPower = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M18.36 6.64a9 9 0 1 1-12.73 0"/><line x1="12" y1="2" x2="12" y2="12"/></svg>;

        // --- BANCO DE FRASES (RESUMIDO) ---
        const PHRASE_LIST = [
            "atras", "frio", "ayuda", "muerte", "luz", "oscuridad", "obregon", "tumba",
            "vete", "aqui", "escucho", "miedo", "niño", "agua", "fuego", "piedra",
            "corre", "espera", "nombre", "tiempo", "dolor", "soledad", "madre", "padre",
            "espiritu", "señal", "ruido", "silencio", "cierra", "abre", "mira", "baja",
            "sube", "cerca", "lejos", "tierra", "cielo", "infierno", "demonio", "angel",
            "rojo", "negro", "sangre", "llanto", "risas", "grito", "buscar", "encontrar",
            "hola", "adios", "estas", "nosotros", "ellos", "cuidado", "peligro", "sueño",
            "somos_cuatro", "estamos_aca", "detras_de_ti", "tuve_un_accidente", 
            "quiero_visitar_mi_familia", "no_me_puedo_ir", "ayudame_a_salir",
            "estoy_perdido", "quien_eres", "busco_la_luz", "hace_frio_aqui",
            "no_te_queremos", "dejanos_en_paz", "estoy_enterrado", "bajo_el_suelo",
            "mira_detras", "no_respiro", "donde_estoy", "somos_muchos",
            "ven_con_nosotros", "te_estoy_viendo", "escucha_mi_voz", "no_es_tu_lugar",
            "estoy_quemandome", "fue_un_error", "sueltame", "ya_es_tarde",
            "rezar_no_sirve", "estamos_esperando", "la_puerta_esta_abierta",
            "aqui_estoy", "no_te_vayas", "escuchame", "estoy_aqui", "no_mires", 
            "no_puedo", "ven", "mirame", "no_corras", "estoy_solo", "no_salgas", 
            "tengo_frio", "nos_escuchan", "no_es_seguro", "quedate", "estoy_atrapado",
            "sigueme", "no_grites", "estoy_muerto", "no_respires", "estoy_contigo",
            "ya_viene", "estoy_cansado", "escucha_bien", "no_huyas", "me_duele",
            "aqui_no", "esta_oscuro", "no_hay_salida", "no_me_toques", "me_llamaron",
            "esta_cerca", "no_te_acerques", "no_duermas", "me_ves", "no_mires_atras",
            "estoy_debajo", "no_hables", "me_oyes", "esta_aqui", "no_cierres",
            "estoy_arriba", "no_confies", "me_quede", "aqui_dentro", "no_lo_sabes",
            "estoy_cayendo", "no_saldra", "me_dejaron", "esta_vivo", "no_despiertes",
            "estoy_roto", "no_entiendes", "me_llamas", "aqui_sigo", "no_lo_mires",
            "estoy_sangrando", "no_es_real", "me_perdi", "esta_mal", "no_escuches",
            "estoy_solo_aqui", "no_te_muevas", "me_buscan", "aqui_abajo", "no_puedo_salir",
            "estoy_mirando", "no_lo_abras", "me_oyen", "esta_abierto", "no_me_sigas",
            "estoy_esperando_aqui", "no_te_escondas", "me_olvidaron", "aqui_termina",
            "no_regreses", "estoy_despierto", "no_resistas", "me_escuchas", "esta_oscuro_aqui",
            "no_confies_en_ellos", "estoy_cerca_de_ti", "no_te_vayas_solo", "me_duele_mucho",
            "aqui_nadie", "no_soy_humano", "estoy_atrapado_aqui", "no_lo_intentes",
            "me_quede_atras", "esta_frio", "no_puedo_ver", "estoy_observando",
            "no_grites_aqui", "me_dejaron_solo"
        ];

        const INTELLIGENT_RESPONSES = {
            identidad: {
                triggers: ["quien", "eres", "nombre", "llamas", "identificate", "como", "llamar"],
                responses: ["soy_nadie", "me_olvidaron", "un_espiritu", "estoy_muerto", "no_soy_humano", "quien_eres", "me_llamas"]
            },
            ubicacion: {
                triggers: ["donde", "estas", "ubicacion", "muestrate", "aqui", "lugar", "ver", "manifiestate"],
                responses: ["estoy_aqui", "detras_de_ti", "aqui_abajo", "aqui_dentro", "cerca", "lejos", "bajo_el_suelo", "mira_detras", "aqui_estoy"]
            },
            estado: {
                triggers: ["como", "sientes", "duele", "paz", "luz", "triste", "enojado", "frio"],
                responses: ["me_duele", "tengo_frio", "estoy_quemandome", "estoy_roto", "estoy_perdido", "estoy_sangrando", "miedo", "dolor"]
            },
            accion: {
                triggers: ["quieres", "hacer", "buscas", "atacar", "daño", "vete", "largo"],
                responses: ["ayuda", "ayudame_a_salir", "sueltame", "no_te_vayas", "ven_con_nosotros", "sigueme", "no_me_sigas", "vete", "largo"]
            },
            cantidad: {
                triggers: ["cuantos", "hay", "son", "grupo", "solos", "acompañado"],
                responses: ["somos_cuatro", "somos_muchos", "estoy_solo", "nosotros", "ellos", "nadie"]
            }
        };

        const App = () => {
            const [isLoaded, setIsLoaded] = useState(false);
            const [loadProgress, setLoadProgress] = useState(0);
            const [isOn, setIsOn] = useState(false);
            const [isStarting, setIsStarting] = useState(false);
            const [statusText, setStatusText] = useState("EN ESPERA");
            const [detectedWord, setDetectedWord] = useState("");
            const [currentAudio, setCurrentAudio] = useState(null);
            
            const videoRef = useRef(null);
            const audioBuffers = useRef({});
            const audioContext = useRef(null);
            const analyser = useRef(null);
            const backgroundSource = useRef(null);
            const voiceSource = useRef(null);
            const recognition = useRef(null);
            const nextRandomTime = useRef(0);
            const isSpeaking = useRef(false);
            const canvasRef = useRef(null);
            const animationRef = useRef(null);

            useEffect(() => {
                const loadAllAudios = async () => {
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    audioContext.current = new AudioCtx();
                    analyser.current = audioContext.current.createAnalyser();
                    analyser.current.fftSize = 256; 
                    analyser.current.connect(audioContext.current.destination);

                    const total = PHRASE_LIST.length + 1;
                    let loaded = 0;

                    const updateProgress = () => {
                        loaded++;
                        setLoadProgress(Math.round((loaded / total) * 100));
                        if (loaded === total) setTimeout(() => setIsLoaded(true), 1500); // 1.5s extra para ver el logo
                    };

                    try {
                        const bgRes = await fetch(BACKGROUND_AUDIO);
                        const bgBuffer = await bgRes.arrayBuffer();
                        audioBuffers.current['BACKGROUND'] = await audioContext.current.decodeAudioData(bgBuffer);
                        updateProgress();
                    } catch (e) { updateProgress(); }

                    for (const phrase of PHRASE_LIST) {
                        try {
                            const res = await fetch(`${AUDIO_BASE_PATH}${phrase}.mp3`);
                            if (res.ok) {
                                const buffer = await res.arrayBuffer();
                                audioBuffers.current[phrase] = await audioContext.current.decodeAudioData(buffer);
                            } else { updateProgress(); }
                        } catch (e) { updateProgress(); }
                        updateProgress();
                    }
                };
                loadAllAudios();
            }, []);

            const handleTogglePower = async () => {
                if (isOn) {
                    setIsOn(false);
                    stopAll();
                    setStatusText("SISTEMA DETENIDO");
                    if (videoRef.current && videoRef.current.srcObject) {
                        videoRef.current.srcObject.getTracks().forEach(track => track.stop());
                        videoRef.current.srcObject = null;
                    }
                } else {
                    setIsStarting(true);
                    setStatusText("INICIANDO...");
                    try {
                        if (audioContext.current && audioContext.current.state === 'suspended') {
                            await audioContext.current.resume();
                        }
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
                            audio: true 
                        });
                        if (videoRef.current) videoRef.current.srcObject = stream;
                        
                        const micSource = audioContext.current.createMediaStreamSource(stream);
                        micSource.connect(analyser.current);

                        setIsOn(true);
                        setStatusText("ESCANEANDO...");
                    } catch (err) {
                        setStatusText("ERROR CAMARA");
                        setIsOn(true); 
                    } finally {
                        setIsStarting(false);
                    }
                }
            };

            const playSound = (bufferName, isBackground = false, volume = 1.0) => {
                if (!audioContext.current || !audioBuffers.current[bufferName]) return;
                
                const source = audioContext.current.createBufferSource();
                source.buffer = audioBuffers.current[bufferName];
                const gainNode = audioContext.current.createGain();
                gainNode.gain.value = volume;
                
                source.connect(gainNode);
                gainNode.connect(analyser.current);

                if (isBackground) {
                    source.loop = true;
                    backgroundSource.current = source;
                    source.start(0);
                } else {
                    if (voiceSource.current) try { voiceSource.current.stop(); } catch(e){}
                    voiceSource.current = source;
                    isSpeaking.current = true;
                    setCurrentAudio(bufferName);
                    source.start(0);
                    source.onended = () => {
                        isSpeaking.current = false;
                        setCurrentAudio(null);
                    };
                }
            };

            const stopAll = () => {
                if (backgroundSource.current) backgroundSource.current.stop();
                if (voiceSource.current) voiceSource.current.stop();
                isSpeaking.current = false;
                setCurrentAudio(null);
            };

            const drawWaveform = () => {
                if (!isOn || !analyser.current || !canvasRef.current) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const bufferLength = analyser.current.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.current.getByteTimeDomainData(dataArray);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ef4444';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ef4444';
                ctx.beginPath();

                const sliceWidth = canvas.width * 1.0 / bufferLength;
                let x = 0;

                for(let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                ctx.lineTo(canvas.width, canvas.height/2);
                ctx.stroke();
                animationRef.current = requestAnimationFrame(drawWaveform);
            };

            useEffect(() => {
                if (isOn) {
                    drawWaveform();
                } else {
                    cancelAnimationFrame(animationRef.current);
                }
                return () => cancelAnimationFrame(animationRef.current);
            }, [isOn]);

            useEffect(() => {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognition.current = new SpeechRecognition();
                    recognition.current.continuous = true;
                    recognition.current.lang = 'es-MX';
                    recognition.current.interimResults = false;
                    recognition.current.onresult = (event) => {
                        const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase();
                        setDetectedWord(transcript);
                        processQuestion(transcript);
                    };
                }
            }, []);

            const processQuestion = (text) => {
                if (!isOn) return;
                let matchFound = false;
                for (const [category, data] of Object.entries(INTELLIGENT_RESPONSES)) {
                    if (data.triggers.some(trigger => text.includes(trigger))) {
                        const response = data.responses[Math.floor(Math.random() * data.responses.length)];
                        setStatusText(`DETECTADO: ${category.toUpperCase()}`);
                        playSound(response, false, 1.0);
                        matchFound = true;
                        nextRandomTime.current = Date.now() + 4000;
                        break;
                    }
                }
                if (!matchFound) setStatusText("ESCUCHANDO...");
            };

            useEffect(() => {
                let interval;
                if (isOn) {
                    playSound('BACKGROUND', true, 0.4);
                    try { recognition.current.start(); } catch(e){}
                    interval = setInterval(() => {
                        const now = Date.now();
                        if (!isSpeaking.current && now > nextRandomTime.current) {
                            if (Math.random() > 0.6) {
                                const randomPhrase = PHRASE_LIST[Math.floor(Math.random() * PHRASE_LIST.length)];
                                playSound(randomPhrase, false, 0.9);
                                nextRandomTime.current = now + (Math.random() * 4000 + 4000);
                            }
                        }
                    }, 1000);
                } else {
                    try { recognition.current.stop(); } catch(e){}
                }
                return () => clearInterval(interval);
            }, [isOn]);

            // --- RENDERIZADO ---
            
            // 1. PANTALLA DE CARGA CON LOGO
            if (!isLoaded) {
                return (
                    <div className="h-screen w-full bg-black flex flex-col items-center justify-center font-mono relative overflow-hidden">
                        {/* Fondo animado sutil */}
                        <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-red-900/20 via-black to-black animate-pulse"></div>
                        
                        <div className="z-10 flex flex-col items-center">
                            {/* LOGO CON EFECTO LATIDO */}
                            <img 
                                src={LOGO_PATH} 
                                alt="OBR Logo" 
                                className="w-48 h-48 object-contain mb-8 logo-spectral"
                                onError={(e) => { e.target.style.display = 'none'; }} 
                            />
                            
                            <div className="text-red-600 text-xs tracking-[0.3em] mb-4 animate-pulse">INICIANDO SISTEMA...</div>
                            
                            <div className="w-64 h-1 bg-gray-900 rounded-full overflow-hidden border border-red-900/30">
                                <div className="h-full bg-red-600 transition-all duration-300" style={{ width: `${loadProgress}%` }}></div>
                            </div>
                            <p className="text-[10px] text-gray-500 mt-2">{loadProgress}% CARGADO</p>
                        </div>
                    </div>
                );
            }

            // 2. APP PRINCIPAL
            return (
                <div className="h-screen w-full bg-black relative overflow-hidden">
                    <video id="camera-feed" ref={videoRef} autoPlay playsInline muted></video>
                    <div className="night-vision-overlay"></div>
                    <div className="tactical-grid"></div>

                    <div className="ui-layer px-4 py-6 justify-between">
                        <div className="flex justify-between items-start bg-black/60 p-2 rounded border-l-4 border-red-600 backdrop-blur-sm shadow-lg">
                            <div>
                                <h1 className="text-xl font-bold text-white tracking-widest flex items-center gap-2">
                                    <IconGhost className="w-5 h-5 text-red-500" /> OBR-VOX
                                </h1>
                                <p className="text-[10px] text-red-400 mt-1 font-bold">RED EDITION v10</p>
                            </div>
                            <div className="text-right">
                                <div className="text-[9px] text-gray-400 tracking-widest">ESTADO</div>
                                <div className={`text-xs font-black tracking-wider ${isOn ? 'text-green-500' : 'text-red-600'}`}>
                                    {isOn ? 'EN LÍNEA' : 'OFFLINE'}
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 flex flex-col items-center justify-center">
                            {currentAudio ? (
                                <div className="text-center w-full slam-in">
                                    <h2 className="terror-text text-7xl font-black uppercase leading-none break-words px-2">
                                        {currentAudio.replace(/_/g, " ")}
                                    </h2>
                                </div>
                            ) : (
                                isOn && (
                                    <div className="text-center opacity-70">
                                        <p className="text-[10px] text-red-500 tracking-[0.5em] animate-pulse bg-black/80 px-2 py-1">BUSCANDO SEÑAL...</p>
                                    </div>
                                )
                            )}
                        </div>

                        <div className="flex flex-col gap-4">
                            <div className="h-6 text-center">
                                {isOn && detectedWord && (
                                    <span className="text-xs font-mono text-white bg-red-900/80 px-3 py-1 rounded shadow-lg border border-red-500/30">
                                        TU: {detectedWord}
                                    </span>
                                )}
                            </div>

                            <div className="h-20 w-full bg-black/90 border-x-2 border-red-600 relative overflow-hidden">
                                <canvas ref={canvasRef} width="400" height="100" className="w-full h-full"></canvas>
                                <div className="absolute top-1 right-2 text-[8px] text-red-500 animate-pulse">REC ●</div>
                            </div>

                            <button 
                                onClick={handleTogglePower}
                                disabled={isStarting}
                                className={`w-full h-20 clip-path-polygon font-black tracking-[0.2em] text-xl transition-all active:scale-[0.98] flex items-center justify-center gap-3 border-2 shadow-2xl ${
                                    isOn 
                                    ? 'bg-red-800 text-white border-red-500 shadow-[0_0_40px_rgba(220,38,38,0.6)]' 
                                    : 'bg-gray-900 text-gray-500 border-gray-700'
                                }`}
                                style={{ clipPath: 'polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px)' }}
                            >
                                {isStarting ? (
                                    <IconActivity className="w-8 h-8 animate-spin" />
                                ) : (
                                    <>
                                        <IconPower className="w-6 h-6" />
                                        {isOn ? 'APAGAR' : 'ENCENDER'}
                                    </>
                                )}
                            </button>
                            
                            <div className="text-center text-[8px] text-gray-500 font-mono tracking-widest opacity-50">
                                SISTEMA DE COMUNICACIÓN OBR // V.3.0
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
