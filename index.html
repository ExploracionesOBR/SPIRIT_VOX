<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OBR Vox - Red Edition</title>
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="./manifest.json">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body { 
            background-color: #000;
            color: #ef4444; /* Rojo base */
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            filter: grayscale(100%) contrast(1.2) brightness(0.6);
            transform: scaleX(1);
        }

        .night-vision-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 0, 0, 0.4);
            pointer-events: none;
            z-index: 1;
            box-shadow: inset 0 0 150px rgba(0,0,0,1);
        }

        .ui-layer {
            position: relative;
            z-index: 10;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .tactical-grid {
            background-image: 
                linear-gradient(rgba(239, 68, 68, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(239, 68, 68, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 2;
        }

        /* --- EFECTO TERROR PARA EL TEXTO --- */
        .terror-text {
            color: #ffffff;
            text-shadow: 4px 4px 0px #8b0000;
            animation: terror-shake 0.3s infinite;
            transform-origin: center;
        }

        @keyframes terror-shake {
            0% { transform: translate(1px, 1px) rotate(0deg); text-shadow: 4px 4px 0px #8b0000; }
            20% { transform: translate(-3px, 0px) rotate(-1deg); text-shadow: -4px 4px 0px #ff0000; opacity: 0.9;}
            40% { transform: translate(1px, -1px) rotate(1deg); text-shadow: 4px -4px 0px #8b0000; }
            60% { transform: translate(-3px, 1px) rotate(0deg); text-shadow: -4px -4px 0px #ff0000; opacity: 1;}
            80% { transform: translate(-1px, -1px) rotate(1deg); text-shadow: 2px 2px 0px #8b0000; }
            100% { transform: translate(1px, -2px) rotate(-1deg); text-shadow: 4px 4px 0px #ff0000; }
        }

        .slam-in {
            animation: slam 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes slam {
            0% { transform: scale(3); opacity: 0; }
            50% { transform: scale(0.9); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .logo-spectral {
            animation: spectral-pulse 3s infinite ease-in-out;
        }
        @keyframes spectral-pulse {
            0% { filter: drop-shadow(0 0 5px rgba(220, 38, 38, 0.2)) grayscale(100%); opacity: 0.7; transform: scale(1); }
            50% { filter: drop-shadow(0 0 25px rgba(255, 0, 0, 0.8)) grayscale(0%); opacity: 1; transform: scale(1.05); }
            100% { filter: drop-shadow(0 0 5px rgba(220, 38, 38, 0.2)) grayscale(100%); opacity: 0.7; transform: scale(1); }
        }
        
        /* Scrollbar personalizada para el modal */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #1a0505;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #7f1d1d;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- CONFIGURACIÓN ---
        const AUDIO_BASE_PATH = 'audios/';
        const BACKGROUND_AUDIO = 'FONDO_1.mp3';
        const LOGO_PATH = 'obr-logo.png';

        // --- ICONOS ---
        const IconGhost = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M9 10h.01"/><path d="M15 10h.01"/><path d="M12 2a8 8 0 0 0-8 8v12l3-3 2.5 2.5L12 19l2.5 2.5L17 19l3 3V10a8 8 0 0 0-8-8z"/></svg>;
        const IconActivity = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>;
        const IconPower = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M18.36 6.64a9 9 0 1 1-12.73 0"/><line x1="12" y1="2" x2="12" y2="12"/></svg>;
        const IconSettings = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const IconPlay = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="5 3 19 12 5 21 5 3"/></svg>;
        const IconX = (props) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>;

        // --- UTILIDAD DE LIMPIEZA DE NOMBRES ---
        const cleanFilename = (text) => {
            return text.toLowerCase().trim()
                .replace(/ /g, "_")
                .replace(/ñ/g, "n")
                .replace(/[á]/g, "a").replace(/[é]/g, "e").replace(/[í]/g, "i").replace(/[ó]/g, "o").replace(/[ú]/g, "u")
                .replace(/[¿?¡!,.]/g, "");
        };

        // --- BANCO DE FRASES DISPONIBLE ---
        const PHRASE_LIST = [
            // Respuestas Específicas
            "Juan", "María", "Pedro", "Ana", "Luis", "Carmen", "Carlos", "Lucía", 
            "Miguel", "Elena", "Roberto", "Sofía", "David", "Laura", "José", "Isabel",
            "Me llamo Juan", "Soy María", "Mi nombre es Pedro", "No tengo nombre", 
            "Me dicen el sombra", "Soy el guardián", "Olvidé mi nombre", "Nadie",
            "Uno", "Dos", "Tres", "Cinco", "Seis", "Siete", "Ocho", "Nueve", "Diez",
            "Somos dos", "Somos tres", "Somos cinco", "Somos seis", "Somos legión", 
            "Hay muchos aquí", "Solo yo", "Incontables", "Cientos", "Todos nosotros",

            // Frases Completas
            "somos cuatro", "estamos acá", "detrás de ti", "tuve un accidente", 
            "quiero visitar mi familia", "no me puedo ir", "ayúdame a salir",
            "estoy perdido", "quién eres", "busco la luz", "hace frío aquí",
            "no te queremos", "déjanos en paz", "estoy enterrado", "bajo el suelo",
            "mira detrás", "no respiro", "dónde estoy", "somos muchos",
            "ven con nosotros", "te estoy viendo", "escucha mi voz", "no es tu lugar",
            "estoy quemándome", "fue un error", "suéltame", "ya es tarde",
            "rezar no sirve", "estamos esperando", "la puerta está abierta",

            // Palabras Simples
            "atrás", "frío", "ayuda", "muerte", "luz", "oscuridad", "obregón", "tumba",
            "vete", "aquí", "escucho", "miedo", "niño", "agua", "fuego", "piedra",
            "corre", "espera", "nombre", "tiempo", "dolor", "soledad", "madre", "padre",
            "espíritu", "señal", "ruido", "silencio", "cierra", "abre", "mira", "baja",
            "sube", "cerca", "lejos", "tierra", "cielo", "infierno", "demonio", "ángel",
            "rojo", "negro", "sangre", "llanto", "risas", "grito", "buscar", "encontrar",
            "hola", "adiós", "estás", "nosotros", "ellos", "cuidado", "peligro", "sueño",
            "Aquí estoy", "No te vayas", "Escúchame", "Estoy aquí", "No mires", 
            "No puedo", "Ven", "Mírame", "No corras", "Estoy solo", "No salgas", 
            "Tengo frío", "Nos escuchan", "No es seguro", "Quédate", "Estoy atrapado", 
            "No me ves", "Sígueme", "No grites", "Estoy muerto", "No respires", 
            "Estoy contigo", "No lo hagas", "Ya viene", "Estoy cansado", "Escucha bien", 
            "No huyas", "Me duele", "Aquí no", "Está oscuro", "No hay salida", 
            "No me toques", "Me llamaron", "Está cerca", "No te acerques", 
            "No duermas", "Me ves", "No mires atrás", "Estoy debajo", "No hables", 
            "Me oyes", "Está aquí", "No cierres", "Estoy arriba", "No confíes", 
            "Me quedé", "Aquí dentro", "No lo sabes", "Estoy cayendo", "No saldrá", 
            "Me dejaron", "Está vivo", "No despiertes", "Estoy roto", "No entiendes", 
            "Me llamas", "Aquí sigo", "No lo mires", "Estoy sangrando", "No es real", 
            "Me perdí", "Está mal", "No escuches", "Estoy solo aquí", "No te muevas", 
            "Me buscan", "Aquí abajo", "No puedo salir", "Estoy mirando", "No lo abras", 
            "Me oyen", "Está abierto", "No me sigas", "Estoy esperando aquí", 
            "No te escondas", "Me olvidaron", "Aquí termina", "No regreses", 
            "Estoy despierto", "No resistas", "Me escuchas", "Está oscuro aquí", 
            "No confíes en ellos", "Estoy cerca de ti", "No te vayas solo", 
            "Me duele mucho", "Aquí nadie", "No soy humano", "Estoy atrapado aquí", 
            "No lo intentes", "Me quedé atrás", "Está frío", "No puedo ver", 
            "Estoy observando", "No grites aquí", "Me dejaron solo"
        ];

        const App = () => {
            const [isLoaded, setIsLoaded] = useState(false);
            const [loadProgress, setLoadProgress] = useState(0);
            const [isOn, setIsOn] = useState(false);
            const [isStarting, setIsStarting] = useState(false);
            const [statusText, setStatusText] = useState("EN ESPERA");
            const [detectedWord, setDetectedWord] = useState("");
            const [currentAudio, setCurrentAudio] = useState(null);
            
            // Estado para el menú de configuración
            const [showSettings, setShowSettings] = useState(false);
            const [loadedFilesList, setLoadedFilesList] = useState([]); // Lista de audios cargados OK
            
            const videoRef = useRef(null);
            const audioBuffers = useRef({});
            const audioContext = useRef(null);
            const analyser = useRef(null);
            const backgroundSource = useRef(null);
            const voiceSource = useRef(null);
            const recognition = useRef(null);
            const nextRandomTime = useRef(0);
            const isSpeaking = useRef(false);
            const canvasRef = useRef(null);
            const animationRef = useRef(null);

            // 1. CARGA DE AUDIOS
            useEffect(() => {
                const loadAllAudios = async () => {
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    audioContext.current = new AudioCtx();
                    analyser.current = audioContext.current.createAnalyser();
                    analyser.current.fftSize = 256; 
                    analyser.current.connect(audioContext.current.destination);

                    const uniquePhrases = [...new Set(PHRASE_LIST)];
                    const total = uniquePhrases.length + 1;
                    let loaded = 0;

                    const updateProgress = () => {
                        loaded++;
                        setLoadProgress(Math.round((loaded / total) * 100));
                        if (loaded === total) setTimeout(() => setIsLoaded(true), 1500); 
                    };

                    try {
                        const bgRes = await fetch(BACKGROUND_AUDIO);
                        if (bgRes.ok) {
                            const bgBuffer = await bgRes.arrayBuffer();
                            audioBuffers.current['BACKGROUND'] = await audioContext.current.decodeAudioData(bgBuffer);
                        }
                    } catch (e) {}
                    updateProgress();

                    for (const phraseDisplay of uniquePhrases) {
                        const filename = cleanFilename(phraseDisplay) + ".mp3";
                        try {
                            const res = await fetch(`${AUDIO_BASE_PATH}${filename}`);
                            if (res.ok) {
                                const buffer = await res.arrayBuffer();
                                audioBuffers.current[phraseDisplay] = await audioContext.current.decodeAudioData(buffer);
                                // Agregar a la lista de archivos disponibles para el menú
                                setLoadedFilesList(prev => [...prev, phraseDisplay]);
                            }
                        } catch (e) {}
                        updateProgress();
                    }
                };
                loadAllAudios();
            }, []);

            // 2. REPRODUCIR PREVIEW (Desde el menú de configuración)
            const playPreview = (phraseName) => {
                if (!audioContext.current) return;
                
                // Asegurar que el contexto esté activo (importante en móviles)
                if (audioContext.current.state === 'suspended') {
                    audioContext.current.resume();
                }

                // 1. Iniciar Ruido de Fondo
                const bgSource = audioContext.current.createBufferSource();
                bgSource.buffer = audioBuffers.current['BACKGROUND'];
                const bgGain = audioContext.current.createGain();
                bgGain.gain.value = 0.4;
                bgSource.connect(bgGain);
                bgGain.connect(audioContext.current.destination); // Directo a salida, sin analizador para no mover gráficos
                bgSource.loop = true;
                bgSource.start(0);

                // 2. Iniciar Voz
                const vSource = audioContext.current.createBufferSource();
                vSource.buffer = audioBuffers.current[phraseName];
                const vGain = audioContext.current.createGain();
                vGain.gain.value = 1.0;
                vSource.connect(vGain);
                vGain.connect(audioContext.current.destination);
                vSource.start(0);

                // 3. Detener todo al terminar la voz
                vSource.onended = () => {
                    bgSource.stop();
                };
            };

            // 3. ENCENDIDO / APAGADO
            const handleTogglePower = async () => {
                if (isOn) {
                    setIsOn(false);
                    stopAll();
                    setStatusText("SISTEMA DETENIDO");
                    if (videoRef.current && videoRef.current.srcObject) {
                        videoRef.current.srcObject.getTracks().forEach(track => track.stop());
                        videoRef.current.srcObject = null;
                    }
                } else {
                    setIsStarting(true);
                    setStatusText("INICIANDO...");
                    try {
                        if (audioContext.current && audioContext.current.state === 'suspended') {
                            await audioContext.current.resume();
                        }
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
                            audio: true 
                        });
                        if (videoRef.current) videoRef.current.srcObject = stream;
                        
                        const micSource = audioContext.current.createMediaStreamSource(stream);
                        micSource.connect(analyser.current);

                        setIsOn(true);
                        setStatusText("ESCANEANDO...");
                    } catch (err) {
                        setStatusText("ERROR CAMARA");
                        setIsOn(true); 
                    } finally {
                        setIsStarting(false);
                    }
                }
            };

            const playSound = (keyName, isBackground = false, volume = 1.0) => {
                if (!audioContext.current) return;
                
                let buffer = audioBuffers.current[keyName];
                if (!buffer) return;
                
                const source = audioContext.current.createBufferSource();
                source.buffer = buffer;
                const gainNode = audioContext.current.createGain();
                gainNode.gain.value = volume;
                
                source.connect(gainNode);
                gainNode.connect(analyser.current);

                if (isBackground) {
                    source.loop = true;
                    backgroundSource.current = source;
                    source.start(0);
                } else {
                    if (voiceSource.current) try { voiceSource.current.stop(); } catch(e){}
                    voiceSource.current = source;
                    isSpeaking.current = true;
                    setCurrentAudio(keyName); 
                    source.start(0);
                    source.onended = () => {
                        isSpeaking.current = false;
                        setCurrentAudio(null);
                    };
                }
            };

            const stopAll = () => {
                if (backgroundSource.current) backgroundSource.current.stop();
                if (voiceSource.current) voiceSource.current.stop();
                isSpeaking.current = false;
                setCurrentAudio(null);
            };

            const drawWaveform = () => {
                if (!isOn || !analyser.current || !canvasRef.current) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const bufferLength = analyser.current.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.current.getByteTimeDomainData(dataArray);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ef4444';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ef4444';
                ctx.beginPath();

                const sliceWidth = canvas.width * 1.0 / bufferLength;
                let x = 0;

                for(let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                ctx.lineTo(canvas.width, canvas.height/2);
                ctx.stroke();
                animationRef.current = requestAnimationFrame(drawWaveform);
            };

            useEffect(() => {
                if (isOn) {
                    drawWaveform();
                } else {
                    cancelAnimationFrame(animationRef.current);
                }
                return () => cancelAnimationFrame(animationRef.current);
            }, [isOn]);

            useEffect(() => {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    recognition.current = new SpeechRecognition();
                    recognition.current.continuous = true;
                    recognition.current.lang = 'es-MX';
                    recognition.current.interimResults = false;
                    recognition.current.onresult = (event) => {
                        const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase();
                        setDetectedWord(transcript);
                        processQuestion(transcript);
                    };
                }
            }, []);

            const processQuestion = (text) => {
                if (!isOn) return;
                
                const cleanText = cleanFilename(text); 
                let matchFound = false;

                // BUSQUEDA DIRECTA (100% Random Lógica)
                const availablePhrases = PHRASE_LIST.filter(p => audioBuffers.current[p]);
                
                // Intento: Si el usuario dice "Miedo", buscar si existe el audio "Miedo"
                const directMatch = availablePhrases.find(phrase => cleanText.includes(cleanFilename(phrase)));

                if (directMatch) {
                    setStatusText(`RESPUESTA DIRECTA`);
                    playSound(directMatch, false, 1.0);
                    matchFound = true;
                    nextRandomTime.current = Date.now() + 4000;
                } 
                else {
                    // Fallback Random (70% chance)
                    if (Math.random() < 0.7) {
                        setStatusText("BARRIDO...");
                        if (availablePhrases.length > 0) {
                            const randomPhrase = availablePhrases[Math.floor(Math.random() * availablePhrases.length)];
                            playSound(randomPhrase, false, 1.0);
                            nextRandomTime.current = Date.now() + 3000;
                        }
                    } else {
                        setStatusText("SIN SEÑAL...");
                    }
                }
            };

            useEffect(() => {
                let interval;
                if (isOn) {
                    playSound('BACKGROUND', true, 0.4); 
                    try { recognition.current.start(); } catch(e){}
                    interval = setInterval(() => {
                        const now = Date.now();
                        if (!isSpeaking.current && now > nextRandomTime.current) {
                            if (Math.random() > 0.6) {
                                const availablePhrases = PHRASE_LIST.filter(p => audioBuffers.current[p]);
                                if (availablePhrases.length > 0) {
                                    const randomPhrase = availablePhrases[Math.floor(Math.random() * availablePhrases.length)];
                                    playSound(randomPhrase, false, 0.9);
                                    nextRandomTime.current = now + (Math.random() * 4000 + 4000);
                                }
                            }
                        }
                    }, 1000);
                } else {
                    try { recognition.current.stop(); } catch(e){}
                }
                return () => clearInterval(interval);
            }, [isOn]);

            // --- RENDERIZADO ---
            
            // 1. PANTALLA DE CARGA
            if (!isLoaded) {
                return (
                    <div className="h-screen w-full bg-black flex flex-col items-center justify-center font-mono relative overflow-hidden">
                        <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-red-900/20 via-black to-black animate-pulse"></div>
                        <div className="z-10 flex flex-col items-center">
                            <img 
                                src={LOGO_PATH} 
                                alt="OBR Logo" 
                                className="w-48 h-48 object-contain mb-8 logo-spectral"
                                onError={(e) => { e.target.style.display = 'none'; }} 
                            />
                            <div className="text-red-600 text-xs tracking-[0.3em] mb-4 animate-pulse">CARGANDO BANCO DE AUDIO...</div>
                            <div className="w-64 h-1 bg-gray-900 rounded-full overflow-hidden border border-red-900/30">
                                <div className="h-full bg-red-600 transition-all duration-300" style={{ width: `${loadProgress}%` }}></div>
                            </div>
                            <p className="text-[10px] text-gray-500 mt-2">{loadProgress}% COMPLETADO</p>
                        </div>
                    </div>
                );
            }

            // 2. UI PRINCIPAL
            return (
                <div className="h-screen w-full bg-black relative overflow-hidden">
                    <video id="camera-feed" ref={videoRef} autoPlay playsInline muted></video>
                    <div className="night-vision-overlay"></div>
                    <div className="tactical-grid"></div>

                    {/* MODAL DE CONFIGURACIÓN (SETTINGS) */}
                    {showSettings && (
                        <div className="absolute inset-0 z-50 bg-black/95 flex flex-col p-6 font-mono text-red-500 animate-in fade-in duration-200">
                            <div className="flex justify-between items-center mb-6 border-b border-red-900 pb-4">
                                <h2 className="text-xl font-bold tracking-widest flex items-center gap-2">
                                    <IconSettings className="w-6 h-6" /> DIAGNÓSTICO
                                </h2>
                                <button onClick={() => setShowSettings(false)} className="text-gray-400 hover:text-white">
                                    <IconX className="w-8 h-8" />
                                </button>
                            </div>
                            
                            <div className="mb-4 text-xs text-gray-400">
                                <p>ARCHIVOS EN MEMORIA: <span className="text-green-400 font-bold">{loadedFilesList.length}</span> / {PHRASE_LIST.length}</p>
                                <p className="mt-1">PULSA <span className="text-white border border-gray-700 px-1 rounded mx-1">▶</span> PARA PREVISUALIZAR MEZCLA</p>
                            </div>

                            <div className="flex-1 overflow-y-auto custom-scrollbar border border-red-900/30 rounded bg-black/50 p-2">
                                {loadedFilesList.length === 0 ? (
                                    <div className="text-center mt-10 text-gray-600">NO SE HAN CARGADO AUDIOS</div>
                                ) : (
                                    loadedFilesList.map((phrase, idx) => (
                                        <div key={idx} className="flex justify-between items-center p-3 border-b border-gray-900 hover:bg-red-900/10 transition-colors">
                                            <span className="text-sm text-gray-300 truncate w-3/4">{phrase}</span>
                                            <button 
                                                onClick={() => playPreview(phrase)}
                                                className="p-2 bg-green-900/20 text-green-500 rounded hover:bg-green-500 hover:text-black transition-all"
                                            >
                                                <IconPlay className="w-4 h-4" />
                                            </button>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    )}

                    {/* CAPA DE INTERFAZ NORMAL */}
                    <div className="ui-layer px-4 py-6 justify-between">
                        <div className="flex justify-between items-start bg-black/60 p-2 rounded border-l-4 border-red-600 backdrop-blur-sm shadow-lg">
                            <div>
                                <h1 className="text-xl font-bold text-white tracking-widest flex items-center gap-2">
                                    <IconGhost className="w-5 h-5 text-red-500" /> OBR-VOX
                                </h1>
                                <p className="text-[10px] text-red-400 mt-1 font-bold">RED EDITION v10</p>
                            </div>
                            <div className="flex flex-col items-end gap-2">
                                {/* BOTÓN DE SETTINGS */}
                                <button onClick={() => setShowSettings(true)} className="text-gray-400 hover:text-white transition-colors">
                                    <IconSettings className="w-6 h-6" />
                                </button>
                                <div className={`text-xs font-black tracking-wider ${isOn ? 'text-green-500' : 'text-red-600'}`}>
                                    {isOn ? 'EN LÍNEA' : 'OFFLINE'}
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 flex flex-col items-center justify-center">
                            {currentAudio ? (
                                <div className="text-center w-full slam-in">
                                    <h2 className="terror-text text-6xl font-black uppercase leading-none break-words px-2">
                                        {currentAudio}
                                    </h2>
                                </div>
                            ) : (
                                isOn && (
                                    <div className="text-center opacity-70">
                                        <p className="text-[10px] text-red-500 tracking-[0.5em] animate-pulse bg-black/80 px-2 py-1">BUSCANDO SEÑAL...</p>
                                    </div>
                                )
                            )}
                        </div>

                        <div className="flex flex-col gap-4">
                            <div className="h-6 text-center">
                                {isOn && detectedWord && (
                                    <span className="text-xs font-mono text-white bg-red-900/80 px-3 py-1 rounded shadow-lg border border-red-500/30">
                                        TU: {detectedWord}
                                    </span>
                                )}
                            </div>

                            <div className="h-20 w-full bg-black/90 border-x-2 border-red-600 relative overflow-hidden">
                                <canvas ref={canvasRef} width="400" height="100" className="w-full h-full"></canvas>
                                <div className="absolute top-1 right-2 text-[8px] text-red-500 animate-pulse">REC ●</div>
                            </div>

                            <button 
                                onClick={handleTogglePower}
                                disabled={isStarting}
                                className={`w-full h-20 clip-path-polygon font-black tracking-[0.2em] text-xl transition-all active:scale-[0.98] flex items-center justify-center gap-3 border-2 shadow-2xl ${
                                    isOn 
                                    ? 'bg-red-800 text-white border-red-500 shadow-[0_0_40px_rgba(220,38,38,0.6)]' 
                                    : 'bg-gray-900 text-gray-500 border-gray-700'
                                }`}
                                style={{ clipPath: 'polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px)' }}
                            >
                                {isStarting ? (
                                    <IconActivity className="w-8 h-8 animate-spin" />
                                ) : (
                                    <>
                                        <IconPower className="w-6 h-6" />
                                        {isOn ? 'APAGAR' : 'ENCENDER'}
                                    </>
                                )}
                            </button>
                            
                            <div className="text-center text-[8px] text-gray-500 font-mono tracking-widest opacity-50">
                                SISTEMA DE COMUNICACIÓN OBR // V.3.0
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
